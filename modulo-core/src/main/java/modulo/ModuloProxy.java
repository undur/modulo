package modulo;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.util.UUID;
import java.util.function.Function;

import org.eclipse.jetty.client.Response;
import org.eclipse.jetty.http.HttpURI;
import org.eclipse.jetty.io.Content;
import org.eclipse.jetty.proxy.ProxyHandler;
import org.eclipse.jetty.server.Request;
import org.eclipse.jetty.server.handler.ErrorHandler;
import org.eclipse.jetty.util.Callback;

/**
 * Subclass of Jetty's proxy handler, allows us to make required modifications to the proxied request before forwarding it to the instance
 */
class ModuloProxy extends ProxyHandler.Reverse {

	public ModuloProxy( Function<Request, HttpURI> httpURIRewriter ) {
		super( httpURIRewriter );
	}

	@Override
	protected void addProxyHeaders( Request clientToProxyRequest, org.eclipse.jetty.client.Request proxyToServerRequest ) {
		super.addProxyHeaders( clientToProxyRequest, proxyToServerRequest );
		proxyToServerRequest.headers( headers -> headers.add( "x-webobjects-adaptor-version", "Modulo" ) ); // mod_WebObjects sends "Apache" here. I have no idea if that's significant, let's assume not
		proxyToServerRequest.headers( headers -> headers.add( "x-webobjects-request-id", UUID.randomUUID().toString() ) ); // Our unique ID does not match the format of the id generated by mod_WebObjects. Doesn't seem to hurt (yet) though. We'll handle it if it turns out to be a problem
		proxyToServerRequest.headers( headers -> headers.add( "x-webobjects-request-method", clientToProxyRequest.getMethod() ) ); // Why mod_WebObjects sends the request method, already an explicit part of the request, as a header as well, I have no idea. But it can't hurt emulating it

		// CHECKME: OK, so this would be the proper way to get the address if we're the front-facing server:
		//		final String clientIPAddress = Request.getRemoteAddr( clientToProxyRequest );
		// ...but since we're probably behind another reverse proxy on the frontend, we're going to read the 'x-forwarded-for' header instead.
		// Which method we pick should really be more intelligent, or specified by configuration. // Hugi 2025-05-07
		final String clientIPAddress = clientToProxyRequest.getHeaders().get( "x-forwarded-for" );

		// Add the remote_addr header
		proxyToServerRequest.headers( headers -> headers.add( "remote_addr", clientIPAddress ) );

		// CHECKME: We're also adding the remote_host header since it was provided by mod_WebObjects.
		// Apache sets this by default to the IP-address, which we do, but it also provided the option of resolving
		// this to the client's hostname by setting "HostnameLookups On", which we currently don't do // Hugi 2025-055-07
		proxyToServerRequest.headers( headers -> headers.add( "remote_host", clientIPAddress ) );

		// By default, Jetty will add itself to the list of user agents on the forwarded request (meaning the user-agent header contains multiple values which may confuse some apps)
		// CHECKME: This really just corrects a mistake made by ourselves so this feels hacky. Ideally, we'd instruct Jetty to never modify the user-agent header in the first place // Hugi 2025-05-07
		final String clientUserAgent = clientToProxyRequest.getHeaders().get( "user-agent" );
		proxyToServerRequest.headers( headers -> headers.put( "user-agent", clientUserAgent ) );
	}

	/**
	 * TODO: Keep track of proxying errors
	 */
	@Override
	protected void onServerToProxyResponseFailure( Request clientToProxyRequest, org.eclipse.jetty.client.Request proxyToServerRequest, Response serverToProxyResponse, org.eclipse.jetty.server.Response proxyToClientResponse, Callback proxyToClientCallback, Throwable failure ) {

		// FIXME: Mark the request so we can identify the error that occurred during error handling and return an appropriate response. Probably lame // Hugi 2025-10-12
		clientToProxyRequest.setAttribute( "modulo-error", "onServerToProxyResponseFailure" );

		super.onServerToProxyResponseFailure( clientToProxyRequest, proxyToServerRequest, serverToProxyResponse, proxyToClientResponse, proxyToClientCallback, failure );
	}

	/**
	 * Generates an error response
	 *
	 * FIXME: Work in progress, currently only generates a little experimental custom message for failure when contacting the remote application // Hugi 2025-10-12
	 */
	public static class ModuloErrorHandler extends ErrorHandler {

		@Override
		public boolean handle( Request request, org.eclipse.jetty.server.Response response, Callback callback ) throws Exception {

			final String moduloError = (String)request.getAttribute( "modulo-error" );

			switch( moduloError ) {
				case "onServerToProxyResponseFailure" -> {
					// HTTP status returned from server
					final int status = (int)request.getAttribute( ErrorHandler.ERROR_STATUS );

					// Error messageg generated by the proxy
					final String errorMessage = (String)request.getAttribute( ErrorHandler.ERROR_MESSAGE );

					// Eception that occurred (probably null for most cases, since a timeout/connection error is more likely than an internal error)
					final Throwable exception = (Throwable)request.getAttribute( ErrorHandler.ERROR_EXCEPTION );

					final Object exceptionClassName = exception != null ? exception.getClass().getName() : "[No further exception information available]";

					final String message = "Error contacting remote app. %s %s. %s".formatted( status, errorMessage, exceptionClassName );
					final byte[] content = message.getBytes( StandardCharsets.UTF_8 );
					final Content.Source cs = Content.Source.from( new ByteArrayInputStream( content ) );
					response.getHeaders().put( "content-length", String.valueOf( content.length ) );
					Content.copy( cs, response, callback );
					return false;
				}
				default -> {
					return super.handle( request, response, callback );
				}
			}
		}
	}
}